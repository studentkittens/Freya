\section{Aufbau des Clients}

Aus den oben genannten Anforderungen kann eine grobe Architektur abgeleitet werden.
Zur Realisierung des Observerpatterns wird die sigc++ library benutzt die mit Gtkmm kommt.
Es wird empfohlen die Einführung bis einschließlich Kapitel 2 zu lesen:
\begin{itemize}
\item \url{http://developer.gnome.org/libsigc++-tutorial/stable/ch01.html}
\end{itemize}
Die ersten Einsätze werden auch noch tiefer erklärt.

%Hier ein erstes Klassendiagramm zu  
%     * BaseClient
%     * Client 
%     * Connection 
%     * Listener
%     * NotifyData
%bzw. deren Verbindung

\subsection{Hauptklassen}

\subsubsection{Listener}
Der Listener verwaltet alles was mit dem Betreten und Verlassen des ,,Idlemodes''
zu tun hat. Er setzt den eingangs beschriebenen ,,Watchdog'' auf die asynchrone Verbindung an,
und ,,parst'' die entsprechenden Antworten des Servers von Hand. 
\\
Bei der Instanzierung des Listener soll das \textit{sigc::signal} welches das Clientupdate darstellt übergeben wird.
Zudem benötigt der Listener eine Referenz auf MPD::Connection um an die darunter liegende asynchrone Verbindung zu kommen.  
\begin{verbatim}
  Listener(EventNotifier& Notifier, Connection& sync_conn);
\end{verbatim}

Bemerkt der Listener Events so ruft er emit() auf dem übergebenen \textit{sigc::signal} auf,
und übergibt als Parameter das aufgetretene Event, sowie eine Instanz von MPD::NotifyData.
Eine weitere Aufgabe ist es das Model MPD::NotifyData aktuell zu halten, sprich bei jedem Clientupdate soll
der aktuelle Status/Song vom Server geholt werden.
\\
Es folgt eine Liste von Funktionen die der Listener mindestens haben soll.
\\
enter() tritt in den ,,Idlemode'' ein. Es ist ab diesem Punkt nicht mehr erlaubt Kommandoes zu senden.
leave() ist das genaue Gegenteil von enter() und verlässt den ,,Idlemode'' sodass Kommandoes gesendet werden können.  
is\_idling() sollte selbsterklärend sein.
\begin{verbatim}
       bool enter(void);
       void leave(void);
       bool is_idling(void);
\end{verbatim}

Es soll zudem eine force\_update() Funktion geben die ,,künstlich'' alle Events auslöst.
Dies ist nützlich bei der Initialisierung, bzw. bei Reconnectvorgängen, wenn die GUI gezwungen werden
soll sich zu updaten.
\begin{verbatim}
       void force_update(void);
\end{verbatim}

\subsubsection{Connection}
\begin{figure}[htb!]
	\centering
        \includegraphics[scale=0.5]{ConnectSequence.pdf}
	\caption{Sequenzdiagramm zum Verbindungsaufbau}
	\label{seq_client_connect}
\end{figure}
Diese Klasse stellt eine Art Wrapper um die \textit{mpd\_connection} Struktur von libmpdclient da.
Sie bietet die ,,eigentlichen'' connect() und disconnect() Methoden die letzlich \textit{mpd\_connection\_new()} bzw. \textit{mpd\_connection\_free()} aufrufen. Siehe \ref{seq_client_connect} für den detaillierten Verbindungsablauf. Die benötigten Verbindungsdaten (Host, Port, Timeout in Sekunden) holt sich MPD::Connection aus der Config.
\\
Sie hält zudem den letzten Host als Membervariable um feststellen zu können ob sich dieser zwischen 
zwei Verbindungsvorgängen geändert hat. Desweiteren bietet sie eine Schnittstelle um andere Klassen über Fehler in der Verbindung informieren zu lassen (signal\_error()), bzw. um sie zu ,,reparieren'' (clear\_error()).
\\
Es folgt eine Liste von Funktionen die mindestens vorhanden sein sollten.
Ein boolean-Rückgabewert von true zeigt stets Erfolg an.
\\
connect() soll die eigentliche Verbindung herstellen, disconnect() löscht die Verbindung wieder.
get\_connection() liefert einen Pointer auf die darunter liegende C-Struktur. Alle 4 Funktionen prüfen 
zudem intern bereits auf Fehler.
\begin{verbatim}
    bool is_connected(void);
    bool connect(void);
    bool disconnect(void);
\end{verbatim}

Zur Implementierung konkreter Kommandoes wird die darunterliegende C-Struktur benötigt.
\begin{verbatim}
    mpd_connection * get_connection(void);
\end{verbatim}

Auf den Rückgabewert dieser Funktionen kann sigc::signal::connect() aufgerufen werden, 
um einen Funktionspointer zu registrieren der aufgerufen wird sobald ein Fehler eintritt,
bzw. sich die Verbindung ändert. Die Prototypen sollen jeweils sein:
\begin{verbatim}
    typedef sigc::signal<void, bool,mpd_error> ErrorNotify;
    typedef sigc::signal<void,bool,bool> ConnectionNotifier;
    
    ErrorNotify& signal_error(void);
    ConnectionNotifier& signal_connection_change(void)
\end{verbatim}

Die Prototypen entsprechen den Templateargumenten in den typedefs:
\begin{verbatim}
    void error_handler(bool is_fatal, mpd_error err_code);
    void conn_change_handler(bool server_changed, bool is_connected); 
\end{verbatim} 

libmpdclient verbietet es weitere Kommandos an den Server zu senden wenn vorher ein Fehler passiert ist.
Fehler müssen zuerst mit \emph{mpd\_connection\_clear\_error()} ,,bereinigt'' werden. 
Dies tut check\_error(). Die Funktion wird normal nicht selbst aufgerufen, da sie von allen anderen Funktionen der Klasse
implizit aufgerufen wird. Ist ein Fehler passiert so werden alle Klienten die sich zuvor
mit signal\_error() registriert haben benachrichtigt. 
\begin{verbatim}
    bool check_error(void);
\end{verbatim}

\begin{figure}[htb!]
	\centering
        \includegraphics[scale=0.55]{BaseClientCollab.png}
	\caption{Klassendiagramm zu BaseClient}
	\label{collab_base_client}
\end{figure}

\subsubsection{BaseClient}
Diese Klasse bildet die Basis zur eigentlichen Clientklasse. Sie kann nicht direkt instanziert werden, da
der Konstruktor protected sein soll.
Sie verwaltet administrative Tätigkeiten wie den eigentlichen Verbindungsaufbau \ref{seq_client_connect} an sich. 
Desweiteren bietet die Klasse einfache Funktionen zum eintreten und verlassen des ,,Idlemodes'' an.
Geht die Verbindung verloren, ohne dass \emph{\_\_disconnect()} explizit aufgerufen wurde, so wird versucht sich periodisch zu reconnecten.
Das Intervall in dem diese Versuche geschehen sollen, soll von ,,settings.connection.reconnectinterval'' gelesen werden.
\\
Er soll mindestens folgende public Methoden bieten:
\\
\\
Gibt eine Referenz auf das zugrunde liegende MPD::Connection Objekt zurück. 
Andere Klassen die Clientkommandos implementieren wollen benötigen dies.
\\
\textbf{Siehe auch:} AbstractClientExtension
\begin{verbatim}
        Connection& get_connection(void);
\end{verbatim}

Gibt \textit{true} zurück wenn eine Verbindung besteht.
\begin{verbatim}
        bool is_connected(void);
\end{verbatim}

Die get\_status() Funktion soll den letzten aktuellen MPD::Status zurückliefern,
oder \emph{NULL} falls nicht verbunden. Es soll garantiert sein dass stets ein MPD::Status vorliegt,
wenn is\_connected() wahr ergibt.
\begin{verbatim}        
        Status * get_status(void);
\end{verbatim}

Die folgenden Methoden bieten eine Möglichkeit für Clientevents, bzw. für Verbindungsänderungen zu registrieren.
\begin{verbatim}
	typedef sigc::signal<void,mpd_idle,MPD::NotifyData&> EventNotifier;
        EventNotifier& signal_client_update(void);
        
        typedef sigc::signal<void,bool,bool> ConnectionNotifier;
        ConnectionNotifier& signal_connection_change(void);
\end{verbatim}

Registrieren kann man sich über die sigc::signal::connect() Methode:
\begin{verbatim}
 // Callback Funktion
 void on_client_update(

 // Registrieren dieser
 m_Client.signal_client_update().connect(sigc::ptr_fun())
\end{verbatim}

Folgende 3 Funktionen funktionieren genau wie enter(), leave() und force\_update() des Listeners.
Allerdings prüfen sie mit Connection::check\_error() vorher stets auf Fehler.
\begin{verbatim}
        void go_idle(void);
        void go_busy(void);
        void force_update(void);
\end{verbatim}

\subsubsection{Client}
Der Client erbt von BaseClient und implementiert konkrete Commandos wie ,,play'',,,random'' etc.
Er bietet zudem Schnittstellen zur Befüllung der Datenbank, der Queue und des Playlistmanagers, indem 
er die abstrakte Klasse AbstractClientExtension ausimplementiert.
Er bietet die Methoden connect() und disconnect() die letzendlich von Anwendern der Clientklasse zum verbinden und trennen genutzt werden. 
Ist in der config ,,settings.connection.autoconnect'' gesetzt so connected er sich automatisch.

connect() und disconnect() stellen die öffentliche Schnittstelle zum Verbinden dar.
Sie rufen intern lediglich \_\_connect() bzw. \_\_disconnect() von MPD::BaseClient auf.
\begin{verbatim}
    void connect(void);
    void disconnect(void);
\end{verbatim}

Die ersten 4 Funktionen sollten offensichtlich sein.
playback\_crossfade() weist den MPD Server an zwischen 2 Songs weich zu überblenden. Die Überblendzeit wird
dabei in Sekunden übergeben, wobei 0 das Crossfade komplett ausschaltet.
playback\_pause() hält die aktuelle Wiedergabe an, oder setzt sie fort wenn bereits angehalten.
playback\_seek() springt in den Song mit der ID song\_id an die Stelle abs\_time in Sekunden.
Die ID des momentan spielenden Songs kann durch get\_status() gefunden werden.
Alle Funktionen (mit Ausnahme von playback\_crossfade) im nächsten Block lösen ein "player" Event aus.
\begin{verbatim}
    void playback_next(void);
    void playback_prev(void);
    void playback_stop(void);
    void playback_play(void);
    void playback_crossfade(unsigned seconds);    
    void playback_pause(void);
    void playback_seek(unsigned song_id, unsigned abs_time);
\end{verbatim}

4 Funktionen um jeweils \it random, consume, repeat\rm und \textit{single}-modi umzuschalten.
\begin{verbatim}
    void toggle_random(void);
    void toggle_consume(void);
    void toggle_repeat(void);
    void toggle_single(void);
\end{verbatim}

Todo...
\begin{verbatim}
    void play_song_at_id(unsigned song_id);
    void playlist_save(const char * name);
\end{verbatim}   

Funktionen zum Bearbeiten der Queue. queue\_add() nimmt dabei ein Pfad zu einem Song oder einem Verzeichniss in der Datenbank 
und fügt ihm rekursiv der Queue hinzu. Das Wurzelverzeichniss ist dabei '/'.
queue\_clear() teilt dem Server mit die Queue zu leeren.
queue\_delete() löscht den Song der an der Stelle 'pos' steht. 
\begin{verbatim}
    void queue_add(const char * url);
    void queue_clear(void);
    void queue_delete(unsigned pos);
\end{verbatim}

database\_update() sendet MPD Server Hinweis um DB zu aktualisieren.
database\_rescan() sendet MPD Server Hinweis um DB neu einzulesen (teuer).
\begin{verbatim}
    void database_update(const char * path);
    void database_rescan(const char * path);
\end{verbatim}

Setzen des volumes von 0-100; Abfrage des Volumes sollte über get\_status() erfolgen.
\begin{verbatim}
    void set_volume(unsigned vol);
\end{verbatim}

Folgende Funktionen sollen von AbstractItemGenerator voll implementiert werden.    
\begin{verbatim}

    void fill_queue(AbstractItemlist& data_model);
    void fill_queue_changes(AbstractItemlist& data_model,
                            unsigned last_version,
                            unsigned& first_pos);
    void fill_playlists(AbstractItemlist& data_model);
    void fill_outputs(AbstractItemlist& data_model);
    void fill_filelist(AbstractItemlist& data_model, const char * path);
\end{verbatim}

\subsubsection{NotifyData}
Speichert den Status, den aktuellen Song und die aktuelle Datenbankstatistik.
Bietet zudem eine Funktion um entsprechende Daten bei Aufruf zu updaten.
Die Klasse gehört nach dem MVC Pattern somit der Modelebene an.
Der Listener instanziert NotifyData im Konstruktor und gibt an wann sich dieser updaten soll (über update\_all()).
\\        
Hauptsächlich wird diese Klasse durch bei einem Event an periphere Klasse weitergegeben.
      
Die folgenden 2 Funktionen haben stets einen validen Rückgabewert:
\begin{verbatim}
    Status& get_status(void);
    Statistics& get_statistics(void);
\end{verbatim}

Anmerkung: Die folgenden 2 Funktionen können NULL zurückgeben, falls 
nichts wiedergegeben wird, oder man im ,,Singlemode'' ist.
get\_song() liefert den aktuell spielenden MPD::Song, oder NULL.
get\_next\_song() liefert den als nächstes spielenden MPD::Song oder NULL.
\begin{verbatim} 
    Song * get_song(void);
    Song * get_next_song(void);
\end{verbatim}

Diese Funktion sollte nur vom Listener aufgerufen werden. Sie aktualisiert den internen Zustand
von NotifyData.
\begin{verbatim}
        void update_all(unsigned event);
\end{verbatim}


\subsection{Weitere Klassen}
Desweiteren gibt es einige weitere Klassen die am Rande eine Rolle spielen,
und meist Objektorientierte Wrapperklassen für die C-Strukturen von libmpdclient bereitstellen,
oder im Falle von MPD::AudioOutput und MPD::Playlist eigene Clientkommandos implementieren.

\subsubsection{Song}

Die Song Klasse für Wrapper für mpd\_song Struktur und die dazugehörigen Klassen (libmpdclient).
Soll alle Funktionen von libmpdclient \footnote{http://www.musicpd.org/doc/libmpdclient/song\_8h.html} anbieten,
diese werden hier nur aufgelistet aber nicht erklärt da sie genau wie ihre Vorbilder funktionieren:

\begin{verbatim}
    const char * get_path(void);
    const char * get_tag(enum mpd_tag_type type, unsigned idx);
    unsigned get_duration(void);
    time_t get_last_modified(void);
    void set_pos(unsigned pos);
    unsigned get_pos(void);
    unsigned get_id(void);
\end{verbatim}

MPD::Song soll zudem eine Funktion bieten um die Metadaten des Songs in einer printf änhlichen Art als String zurückzuliefern:
\begin{verbatim}
    Glib::ustring song_format(const char* format, bool markup=true);
\end{verbatim}

Ein beispielhafter Aufruf:
\begin{verbatim}
    SomeSong.song_format("Artist is by ${artist}") 
\end{verbatim}

Die folgenden Tagarten sollen dabei unterstützt werden (sie spiegeln in etwa die mpd\_tag\_type Enumeration von libmpdclient wieder)
Foldende Tags sollen daher unterstützt werden: \it artist, title, album, track, name, data, album\_artist, genre, composer, performer, comment, disc\rm.
Ist ein Escapestring nicht bekannt, so wird er nicht escaped. Ist der tag nicht vorhanden soll mit "unknown" escaped werden.


\subsubsection{Directory}
Die Directory Klasse ist Wrapper für mpd\_directory C-Strukutr. Diese wird als Anzeige für ein Verzeichniss benutzt,
jedoch nicht als Container für andere Elemente.

Entsprechend implementiert bietet MPD::Directory nur:
\begin{verbatim}
    void get_path(void);
\end{verbatim}

Dies ist von der AbstractComposite vorgegeben.

\newpage
\subsubsection{Statistics}
Die Statistics Klasse ist Wrapper für mpd\_stats, implementiert gemäß \url{\\http://www.musicpd.org/doc/libmpdclient/stats\_8h.html}
folgende Funktionen:
\begin{verbatim}
    unsigned get_number_of_artists(void);
    unsigned get_number_of_albums(void);
    unsigned get_number_of_songs(void);
    unsigned long get_uptime(void);
    unsigned long get_db_update_time(void);
    unsigned long get_play_time(void);
    unsigned long get_db_play_time(void);
\end{verbatim}


\subsubsection{Playlist}
Die Playlist Klasse ist Wrapper für die mpd\_playlist Struktur, implementiert von \url{http://www.musicpd.org/doc/libmpdclient/playlist\_8h.html} folgende Funktionen:
\begin{verbatim}
    const char * get_path(void);
    time_t get_last_modified(void);
\end{verbatim}

Bietet desweiteren funktionen zum:
Entfernen der Playlist vom Server (Das Playlistobjekt ist danach invalid):
\begin{verbatim}
    void remove(void);
\end{verbatim}

Laden der Playlist in die Queue:
\begin{verbatim}
    void load(void);
\end{verbatim}

Umbennen der Playlist:
\begin{verbatim}
    void rename(const char * new\_name);
\end{verbatim}

Hinzufügen von Songs zur Playlist:
\begin{verbatim}
    void add_song(const char * uri);
    void add_song(MPD::Song& song);
\end{verbatim}

Die genannten Funktionen benötigen müssen den idlemode verlassen können,
daher leitet MPD::Playlist von AbstractClientExtension ab.

\subsubsection{AudioOutput}
Die AudioOutput Klasse ist ein Wrapper für mpd\_output, implementiert von http://www.musicpd.org/doc/libmpdclient/output\_8h.html folgende Funktionen:
\begin{verbatim}
    unsigned get_id(void);
    const char * get_name(void);
    bool get_enabled(void);
\end{verbatim}

Bietet desweiteren funktionen zum:
\begin{itemize}
    \item Enablen des Ausgabegerätes:
        \begin{verbatim}
            bool enable(void);
        \end{verbatim}
    \item Disablen des Ausgabegerätes:
        \begin{verbatim}
            bool disable(void);
        \end{verbatim}
\end{itemize}


Die genannten Funktionen benötigen müssen den idlemode verlassen können,
daher leitet MPD::AudioOutput von AbstractClientExtension ab. 
\newpage
\subsection{Abstrakte Klassen}
\subsubsection{AbstractClientExtension}
Diese abstrakte Klasse erlaubt abgeleiteten Klasse ähnlich zum BaseClient eigene Kommandos zu implementieren.
Wird von MPD::Playlist und MPD::AudioOutput benutzt 

\begin{figure}[htb!]
	\centering
        \includegraphics[scale=0.6]{AbstractClientExtension.png}
	\caption{Klassendiagramm zu AbstractClientExtension}
	\label{c_abstract_client_extension}
\end{figure}


\subsubsection{AbstractClientUser}
\begin{itemize}
    \item Verwaltet einen Pointer auf die MPD::Client Klasse,
        so dass der Anwender der Klasse dies nicht selbst tun muss.
    \item Leitet man ab so müssen folgenden Methoden implementiert werden:
        \begin{verbatim}
            void on_client_update(enum mpd_idle event, MPD::NotifyData& data);
        \end{verbatim}  

        Wird aufgerufen sobald der Listener eine Änderunge feststellt,
        siehe weiter unten "Interaktion des Clients mit anderen Modulen" für eine genauere Erklärung.
        \begin{verbatim}
            void on_connection_change(bool server_changed, bool is_connected);
        \end{verbatim}

        Wird aufgerufen sobald sich der verbunden/getrennt hat. Im ersten Fall
        ist is\_connected true, im anderen false. Sollte sich der Client verbunden haben,
        und der neue Server entspricht nicht mehr dem neuen so ist auch server\_changed true.
        Dies ist automatisch wahr beim ersten Start.
        Diese werden automatisch durch Ableiten von AbstractClientUser registriert.
        Weiterhin können alle Klassen über den mp\_Client Pointer auf den Client zugreifen.
\end{itemize}


\subsubsection{AbstractItemlist}
Für bestimmte Client funktionen muss eine Nutzerklasse von AbstractItemlist ableiten.
Leitet man ab so muss die Methode add\_item(AbstractComposite * data) implementiert werden. 
Je nach Bedarf kann über \verb+static_cast<Zieltyp*>(data)+ der entsprechende Datentyp rausgecasted werden.
Beim Aufruf von MPD::Client::fill\_queue ruft der Client die add\_item methode für jeden 
song den er vom server bekommt auf. Die ableitende Klasse kann diese dann verarbeiten.

Dadurch werden alle Methoden von AbstractItemGenerator (bzw. die Klassen die davon ableiten) benutzbar.
%<Klassendiagramm, bzw. Klassen die es verwenden von Doxygen nehmen>

\subsubsection{AbstractItemGenerator}
Lässt ableitende Klasse folgende Methoden implementieren:
Jede dieser Methoden ruft MPD::Playlist add\_item() von AbstractItemlist auf um ihre Resultate weiterzugeben.

%<Sequenzdiagramm>   
Holt alle Songs der aktuellen Queue.
\begin{verbatim}            
    void fill_queue(AbstractItemlist& data_model);
\end{verbatim}

Holt alle geänderten Songs in der Queue seit der Version last\_version. Die Position des ersten geänderten Songs wird in first\_pos gespeichert. 
\begin{verbatim}
    void fill_queue_changes(AbstractItemlist& data_model, unsigned last_version, unsigned& first_pos);
\end{verbatim}

Holt alle gespeicherten Playlisten vom Server.
\begin{verbatim}              
    void fill_playlists(AbstractItemlist& data_model);
\end{verbatim}

Holt alle Audio Outputs vom Server.
\begin{verbatim}
    void fill\_outputs(AbstractItemlist& data\_model);
\end{verbatim}

Holt alle Songs und Directories aus der Datenbank im Pfad path (nicht rekursiv!)              
\begin{verbatim}
    void fill_filelist(AbstractItemlist& data_model, const char * path);
\end{verbatim}

%<Klassendiagramm, bzw. Klassen die es verwenden von Doxygen nehmen>

%-------------------------------------------

\subsubsection{AbstractComposite}
Vereinheitlicht Zugriff auf Komponenten verschiedenen Types.
Die abstrakte Klasse zwingt seine Kinder dazu eine \emph{get\_path()} zu implementieren die die Lage im virtuellen Filesystem des Servers angibt.
Der Hauptnutznieser dieser Klasse ist der Databasebrowser, bzw. den dahinter gelagerten Cache Songs und Verzeichnisse gleich zu behandeln.

Die erbende Klasse muss im Konstruktor angeben ob es sich bei der Klasse um ein ,,File'' (\emph{true} für MPD::Song) oder um einen ,,Container'' (\emph{false} für MPD::Directory) handelt.
Diese ,,is\_leaf'' Eigenschaft kann später mit der Funktion \emph{is\_leaf()} abgefragt werden.

% <Klassendiagramm für alle Klassen die von AbstractComposite erben, siehe Doxygen>

%-------------------------------------------

%=============================================