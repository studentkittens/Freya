
\chapter{Software Design}

\section{Einführung}

\subsubsection{Namespace-Übersicht}
<<<<<<< HEAD:doc/architecture/Doku/Dokument/DesignDokument.tex
\subsubsection{Beschreibung}
\subsection{Funktionen}
\subsection{Oberfläche}
\subsubsection{Titelleiste}
\subsubsection{Seitenmenü}
\subsubsection{Fußleiste}
\subsubsection{Anzeige}
\subsection{Short-Cuts}
\section{Use-Case-Fälle}
\subsection{Musik abspielen}
\subsection{Musik zufällig abspielen}
\subsection{Musik im Consume Mode abspielen}
\subsection{Playlist erstellen}
=======

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.21]{Namespace_Uebersicht.png}
    \caption{Die MPD Namespaces im Überblick}
    \label{dd_namespaces}
\end{figure}

\section{,,Das Problem''}

Da die grundlegende Funktionsweise des MPD Server auf einer Client Server Architektur beruht, muss der MPD Client
verschiedene Kommandos wie zum Beispiel play, pause, listplaylists etc. an den Server schicken
und zur gleichen Zeit aber auch auf Änderungen reagieren können, d.h. zum Beispiel wenn sich die Lautstärke ändert,
da jederzeit auch andere Clients oder Server den MPD internen Zustand ändern können.
Diese Änderungen müssen auch anderen Programmteilen bekannt gemacht werden. (Observer Pattern)
\\
Der Client sollte im ,,idle''-Mode möglichst keine Ressourcen verschwenden und auch beim 
disconnecten und conntecten die entprechenden Änderungen anderen Teilen des Programms mitteilen
können(Observer Pattern)\footnote{http://de.wikipedia.org/wiki/Observer\_(Entwurfsmuster)}. 
\\

Das MPD Protokoll \footnote{http://www.musicpd.org/doc/protocol/index.html} bietet folgende Möglichkeiten das zu realisieren
\begin{description}
    \item [Periodisch] (zB. alle 500ms) das ,,status'' command absetzen und nach Bedarf auch commands wie ,,currentsong''
        senden
        \\
        \emph{Problem:} Bei langsamen Netzwerkverbindungen erzeugt dies unnötige Netzwerklast 
        Prinzipiell würde sich auf diese Art jedoch die z. B. Musik Bitrate anzeigen lassen, es ist jedoch ein
        wenig komfortabler Weg da hier wieder einmal das Rad neu erfunden werden müsste.
    \item [Nutzung der ,,idle'' und ,,noidle'' commands:]
        ,,idle'' versetzt die Verbindung zum Server in einen Schlafzustand, sobald ,,events'' wie 'player' (also z. B. pause oder play) 
        eintreten, wacht die Verbindung aus diesem Zustand auf und sendet an den Client eine Liste der Events die aufgetreten sind:

\begin{figure}[h!]
    \lstinputlisting[language=bash]{state.txt}
\caption{Eine Beispielantwort des MPD Servers}
\label{dd_state}
\end{figure}
>>>>>>> katze:doc/architecture/Doku/DesignDokument.tex

        Einschränkung: Während die Verbindung im idle mode ist kann kein reguläres Kommando wie ,,play'' gesendet werden!
        Sollte man es doch tun wird man vom Server augenblicklich mit einem Disconnect belohnt.
        Die einzige Möglichkeit aus dem idle mode aufzuwachen ist das 'noidle' command das gesendet werden
        kann während die verbindung schlafen gelegt wurde.
        Jedoch gibt es auch hier ein Problem, denn das ,,idle'' command blockiert, sprich es sendet kein ,,OK'' zurück zum Sender.
        Ein Warten auf dieses ,,OK'' würde mit den Wunsch eine bedienbare Oberfläche zu haben kollidieren.
\end{description}

Prinzipiell gibt es 2 Möglichkeiten dieses Problem zu lösen:
\begin{itemize}
    \item Man hält zwei Verbindungen zum Server, eine die Kommandos sendet, eine die stets im ,,idle'' mode liegt,
        Für die Realisierung müssten Threads herangezogen werden. Ein Thread würde dann im Hintergrund auf events lauschen,
        der andere würde zum Abschicken der Kommandos benutzt werden.
        Problem: Es müssen 2 Verbindungen gehandelt werden, was wiederum ein Mehraufwand an Code bedeutet.
        Desweiteren werden Threads benötigt die auch in anderen Bereichen des Programms Lockingmechanismen bedeuten würden.
    \item Man hält eine asynchrone verbindung zu dem server.
        Diese kann das 'idle' command zum server schicken, returned aber sofort. Um nun eine Liste der events zu bekommen setzt man 
        einen ,,Watchdog''auf die asynchrone verbindung an (Vergleiche dazu den Systemaufrug 'man 3 poll'). Da poll() ebenfalls den
        aufrufenden Prozess blockiert, wird Glib::signal\_io() benutzt, das sich in den laufenden MainLoop (*) einhängt und eine 
        Callbackfunktion aufruft sobald auf der verbindung etwas interessantes passiert. Da während des Wartens der MainLoop weiterarbeitet,
        bleibt die GUI (und andere Module) aktiv und benutzbar.
        Problem: Vor dem Senden eines Kommandos wie ,,play'' muss der idle mode verlassen werden.
        Lösung: Man kann das ,,noidle'' Kommando zum verlassen senden, und nach dem Absenden des eigentlichen Kommandos wieder den idle-mode betreten.
\end{itemize}

%* MainLoop: Vergleiche Event Dispatcher auf wikipedia. Gtk+ benutzt intern einen MainLoop um auf die user ergebnisse reagieren zu können.
%            Desweiteren kann man eigene events in den Loop einhängen, wie beispielsweise ein Timeoutevent das alle 500ms ausgeführ

\lstinputlisting[language=bash]{telnet.txt}


Die Idee zu dieser Implementierung (speziell das Benutzen einer asynchronen Verbindung), kommt von ,,ncmpc'',
der inoffiziellen offiziellen Referenzimplementierung des MPD Mit-Authors \emph{Max Kellermann}.
Vergleiche \href{http://mpd.wikia.com/wiki/Client:Ncmpc}{ncmpc quellcode}: src/gidle.c und src/mpdclient.c


\input{ClientImplementierung}
\input{Config}
\input{GUIElements}
\input{BrowserImplementierungen}
