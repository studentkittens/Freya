Erklärung zum Client
====================

Ein Client muss:
- Kommandos and den Servers senden können (play,pause,listplaylists etc.)
- Er muss zur selben Zeit auf Änderungen reagieren können (zB. volume changed) - da auch andere clients 
  oder der Server selbst unabhängig etwas ändern können und man darauf reagieren muss.
  Und diese Änderungen anderen Teilen des Programms mitteilen können (Observer Pattern)
- Er sollte solange er nicht aktiv ist keine Ressourcen verschwenden
- Er sollte nach Möglichkeit disconnecten und connecten können, und entsprechende Änderungen 
  anderen teilen des Programms mitteilen können (Observer #2)

Das MPD Protokoll (http://www.musicpd.org/doc/protocol/index.html) bietet folgende Möglichkeiten das zu realisieren
- Periodisch (zB. alle 500ms) das 'status' command absetzen, und nach bedarf commands wie 'currentsong' absetzen.
  Problem: Bei langsamen netzwerkverbindungen erzeugt dies unnötige Netzwerklast (auch wenn sie gering ist)
  Sonst ein gangbarer wenn man zB. Daten wie kbit rate sekündlich anzeigen will.
  Sonst aber ein wenig komfortabler Weg da wieder einmal das Rad neu erfunden werden müsste.

- Nutzung der 'idle' und 'noidle' commands:
  'idle' versetzt die verbindung zum server in einen Schlafzustand, sobald events wie 'player' (also pause oder play zum beispiel) 
  eintreten wacht die verbindung aus diesem Zustand auf und sendet an den client eine liste der events die aufgetreten sind:

     changed: player
     changed: mixer
     ...
     OK

  Einschränkung: Während die Verbindung im idle mode ist kann kein reguläres command wie 'play' gesendet werden!
  Sollte man es doch tun wird man vom Server augenblicklich mit einem Disconnect belohnt.
  Die einzige Möglichkeit aus dem idle mode aufzuwachen ist das 'noidle' command das gesendet werden
  kann während die verbindung schlafen gelegt wurde.
  Jedoch gibt es auch hier ein Problem, denn das idle command blockiert.
  Wir wollen jedoch in der Wartezeit eine Bedienbare GUI.
 
Prinzipiell gibt es 3 Möglichkeiten dieses Problem zu lösen:
- Man hält zwei Verbindungen zum Server, eine die Kommandos sendet, eine die stets im idle mode liegt,
  Für die Realisierung müssten Threads herangezogen werden. Ein Thread würde dann im Hintergrund auf events lauschen.
  Problem: Es müssen 2 Verbindungen gehandelt werden, was wiederum ein Mehraufwand an Code bedeutet.
           Desweiteren werden Threads benötigt die auch in anderen Bereichen des Programms Lockingmechanismen bedeuten würden.

- Man hält eine asynchrone verbindung zu dem server.
  Diese kann das 'idle' command zum server schicken, returned aber sofort. Um nun eine Liste der events zu bekommen setzt man 
  einen "Watchdog" auf die asynchrone verbindung an (Vergleiche dazu den Systemaufrug 'man 3 poll'). Da poll() ebenfalls den
  aufrufenden Prozess blockiert, wird Glib::signal_io() benutzt, das sich in den laufenden MainLoop (*) einhängt und eine 
  Callbackfunktion aufruft sobald auf der verbindung etwas interessantes passiert. Da während des Wartens der MainLoop weiterarbeitet,
  bleibt die GUI (und andere Module) aktiv und benutzbar.
  Problem: Vor dem senden eines Kommandos wie 'play' muss der idle mode verlassen werden.
  Lösung: Man kann das 'noidle' Kommando zum verlassen senden, und nach dem Absenden des eigentlichen Kommandos wieder den idle-mode betreten.
  

* MainLoop: Vergleiche Event Dispatcher auf wikipedia. Gtk+ benutzt intern einen MainLoop um auf die user ergebnisse reagieren zu können.
            Desweiteren kann man eigene events in den Loop einhängen, wie beispielsweise ein Timeoutevent das alle 500ms ausgeführ


Praktische Darstellung
----------------------

Zum praktischen Verständniss kann man eine telnet session zum server aufbauen:


  ➜  Freya git:(master) $ telnet localhost 6600
    Trying ::1...
    Connected to localhost.
    Escape character is '^]'.
    OK MPD 0.16.0                 # Der Server antwortet bei verbindungsaufbau stets mit einem OK und der Versionsnummer
    pause                         # Wir senden das 'pause' kommando zum pausieren des aktuellen liedes
    OK                            # Der Server führt es aus und antwortet mit einem OK
    play                          # Wir tun dasselbe mit dem 'play' command.
    OK  
    idle                          # Wir sagen dem server dass wir die verbindung schlafen legen wollen...
    changed: player               # Er returned aber sofort da seit dem verbindungsaufbau etwas geschehen ist.
    changed: mixer                # Und zwar wurde der Player pausiert, und das volume geändert.
    OK                            # Das Ende des idlemodes wird wieder mit OK angezeigt.
    idle                          # Probieren wir es noch einmal.. 
                                  # Er antwortet nicht mit OK sondern schläft jetzt. Würden wir in einem anderen client pausieren
                                  # So würde er hier aufwachen. 
    noidle                        # Um aus den idlemode vorher aufzuwachen senden wir das noidle command
    OK                            # OK sagt uns dass alles okay ist.
    idle                          # Probieren wir mal ein command zu senden während die verbindung idlet:
    play                          # zum Beispiel das play command... als antwort wird die verbindung geschlossen:
    Connection closed by foreign host.
  ➜  Freya git:(master) $ echo 'ende.'



Die Idee zu dieser Implementierung (speziell das Benutzen einer asynchronen Verbindung), kommt von 'ncmpc',
der inoffiziellen offiziellen Referenzimplementierung des MPD Mit-Authors Max Kellermann.
Vergleiche ncmpc quellcode: src/gidle.c und src/mpdclient.c


AUFBAU DES CLIENTS
==================

Aus den oben genannten Anforderunten kann eine grobe Architektur abgeleitet werden:

<Hier ein erstes Klassendiagramm zu 
     * BaseClient
     * Client 
     * Connection 
     * Listener
     * NotifyData
bzw. deren Verbindung>

Hauptklassen
------------

BaseClient:
- Kann nicht selbst instanziert werden
- Verwaltet connect / disconnect und reconnect vorgänge
- Bietet Funktionen zum einfachen verlassen und eintreten des idlemodes an 
- Implementiert keine konkreten Kommandos die er an den server schicken kann
- Geht die verbindung verloren (ohne dass disconnect() explizit aufgerufen wurde),
  so versucht er periodisch sich zu reconnecten.
  
Listener:
- Verwaltet das ein- und austreten aus dem Idlemode
- Parst die Responseliste (also changed: player)
- Verfügt über ein "EventNotifer" (ein sigc::signal)
  Module können sich über connect() registrieren,
  bemerkt der Listener events so ruft er emit() auf dem signal auf
  und teilt allen anderen Modulen so mit welche events geschehen sind.
- Zudem bietet er eine Möglichkeit ein update zur forcen, das heißt "künstlich" alle
  möglichen events auzulösen was nützlich zum Initialisieren ist (force_update())
- Bei einem connect vorgang wird eine Instanz des Listeners instanziert und 
  sofort der idlemodus betreten
- Bei einem disconnect wird der Listener gelöscht.

Connection:
- Ein Wrapper um die mpd_connection Struktur von libmpdclient
- Ruft letzendlich mpd_connection_new() auf 
- Bietet eine Schnittstelle um sich über Fehler informieren zu lassen (signal_error())
- Bietet eine get_connection() methode die bei jedem aufruf prüft ob fehler passiert sind
  In diesem Falle versucht MPD::Connection den Fehler zu bereinigen (falls ein nicht fataler Fehler war).
  Anschließend benachrichtigt MPD::Connection alle module die sich vorher über signal_error() 
  registriert haben (wie der BaseClient es beispielsweise mit handle_error() tut)

Client:
- Der Client erbt von BaseClient und implementiert konkrete Commandos wie 'play','random' etc.
- Er bietet zudem Schnittstellen zur Befüllung der Datenbank, der Queue und des Playlistmanagers
- Er bietet die Methoden connect() und disconnect() 
- Ist in der config "settings.connection.autoconnect" gesetzt so connected er sich automatisch.
- Er bietet zudem eine schnittstelle um sich beim listener zu registrieren und im falle von 
  änderungen des connection zustands benachrichtigt zu werden.

NotifyData
- Speichert den Status, den aktuellen Song und die aktuelle Datenbankstatistik
- Der Listener...
  - instanziert NotifyData im Konstruktor
  - sagt NotifyData wann er sich updaten soll (update_all())
  - gibt eine Referenz auf NotifyData an alle registrierten Module weiter,
    damit diese konkrete Informationen beziehen können.

=============================================

Sequenzdiagramm (evtl. auch Zustandsdiagramme) für:
- Connect Vorgang; Beteiligt: BaseClient, Listener, Connection, Client
- Senden eines Kommandos; Beteiligt: Beliebige Klasse wie GManager::Timeslide, Client, Listener
- ...

=============================================


Weitere Klassen
---------------
Desweiteren gibt es einige weitere Klassen die am Rande eine Rolle spielen,
und meist Objektorientierte Wrapperklassen für die C-Strukturen von libmpdclient bereitstellen:

MPD::Song
-------------------------------------------------
Wrapper für mpd_song.
Soll alle Funktionen von http://www.musicpd.org/doc/libmpdclient/song_8h.html anbieten,
diese werden hier nur aufgelistet aber nicht erklärt da sie genau wie ihre Vorbilder funktionieren:

            const char * get_path(void);
            const char * get_tag(enum mpd_tag_type type, unsigned idx);
            unsigned get_duration(void);
            time_t get_last_modified(void);
            void set_pos(unsigned pos);
            unsigned get_pos(void);
            unsigned get_id(void);

MPD::Song soll zudem eine Funktion bieten um die Metadaten des Songs in einer printf änhlichen Art als String zurückzuliefern:

            Glib::ustring song_format(const char* format, bool markup=true);

Ein beispielhafter Aufruf:

            SomeSong.song_format("Artist is by ${artist}") 

Die folgenden Tagarten sollen unterstützt werden (sie spiegeln in etwa die mpd_tag_type Enumeration von libmpdclient wieder):
  * artist
  * title
  * album
  * track
  * name
  * data
  * album_artist
  * genre
  * composer
  * performer
  * comment
  * disc
  
Ist ein Escapestring nicht bekannt, so wird er nicht escaped. Ist der tag nicht vorhanden soll mit "unknown" escaped werden.

-------------------------------------------------

Directory
Wrapper für mpd_directory. Wird lediglich als Anzeige für ein Verzeichniss benutzt, nicht als Container für andere Elemente.
Entsprechend implementiert MPD::Directory nur:

            void get_path(void);

...was von AbstractComposite vorgegeben wird.

-------------------------------------------------

Statistics
- Wrapper für mpd_stats, implementiert gemäß http://www.musicpd.org/doc/libmpdclient/stats_8h.html folgende Funktionen:

            unsigned get_number_of_artists(void);
            unsigned get_number_of_albums(void);
            unsigned get_number_of_songs(void);
            unsigned long get_uptime(void);
            unsigned long get_db_update_time(void);
            unsigned long get_play_time(void);
            unsigned long get_db_play_time(void);

-------------------------------------------------
  
Playlist
- Wrapper für mpd_playlist, implementiert von http://www.musicpd.org/doc/libmpdclient/playlist_8h.html folgende Funktionen:

            const char * get_path(void);
            time_t get_last_modified(void);

- Bietet desweiteren funktionen zum:
  * Entfernen der Playlist vom Server (Das Playlistobjekt ist danach invalid):
  
            void remove(void);

  * Laden der Playlist in die Queue:
  
            void load(void);

  * Umbennen der Playlist:
  
            void rename(const char * new_name);

  * Hinzufügen von Songs zur Playlist:
  
            void add_song(const char * uri);
            void add_song(MPD::Song& song);

- Die genannten funktionen benötigen müssen den idlemode verlassen können,
  daher leitet MPD::Playlist von AbstractClientExtension ab.

-------------------------------------------------

AudioOutput
- Wrapper für mpd_output, implementiert von http://www.musicpd.org/doc/libmpdclient/output_8h.html folgende Funktionen:

            unsigned get_id(void);
            const char * get_name(void);
            bool get_enabled(void);

- Bietet desweiteren funktionen zum:
  * Enablen des Ausgabegerätes:
  
            bool enable(void);
    
  * Disablen des Ausgabegerätes:
  
            bool disable(void);

- Die genannten Funktionen benötigen müssen den idlemode verlassen können,
daher leitet MPD::AudioOutput von AbstractClientExtension ab. 

-------------------------------------------------

Abstrakte Klassen
----------------- 
AbstractClientExtension
- Erlaubt abgeleiteten Klasse ähnlich zum Client eigene Kommandos zu implementieren
- Wird von MPD::Playlist und MPD::AudioOutput benutzt 

AbstractClientUser
- Verwaltet einen Pointer auf die MPD::Client Klasse,
  so dass der Anwender der Klasse dies nicht selbst tun muss.
- Registriert zudem automatisch die on_client_update() und die on_connection_change() 
  Funktionen. Daher muss der Ableitende beide Methoden implementieren.

AbstractItemlist
- Für bestimmte Client funktionen muss eine Nutzerklasse von AbstractItemlist ableiten.
  Leitet man ab so muss die Methode add_item(void * data) implementiert werden. 
  Beim Aufruf von MPD::Client::fill_queue ruft der Client die add_item methode für jeden 
  song den er vom server bekommt auf. Die ableitende Klasse kann diese dann verarbeiten.
  
  Dadurch werden alle Methoden von AbstractItemGenerator (bzw. die Klassen die davon ableiten) benutzbar:
  * fill_queue
  * fill_queue_changes
  * fill_playlists
  * fill_ouputs
  * fill_filelist 

=============================================

Interaktion des Clients mit anderen Modulen
-------------------------------------------

- Die meisten GUI Klassen leiten von AbstractClientUser ab und speichern daher eine Referenz auf eine Instanz von MPD::Client
  Sie können daher Funktionen wie queue_add() direkt aufrufen.
- AbstractClientUser zwingt die abgeleitenden Klassen die Funktionen 
    1) void on_client_update(mpd_idle event, MPD::NotifyData& data)
    2) void on_connection_change(bool is_connected)
  zu implementieren.

  1) wird aufgerufen sobald der Listener ein Event festgestellt hat. Für jedes eingetretene Event wird 1)
  einmal aufgerufen. 'event' ist dabei eine Enumeration aller möglichen Events, die von libmpdclient 
  vorgegeben werden. (Siehe auch http://www.musicpd.org/doc/libmpdclient/idle_8h.html#a3378f7a24c714d7cb1058232330d7a1c)
  'data' ist eine Referenz auf eine Instanz von MPD::NotifyData. Die benutzenden Klassen können mit 
    - get_status() gibt den aktuellen MPD::Status
    - get_song() gibt den aktuellen MPD::Song
    - get_statistics() gibt die aktuellen MPD::Statistics 
  so bei Änderungen sofort die aktuellen Änderungen auslesen.


  2) on_connection_change wird vom Client aufgerufen sobald die Verbindung verloren geht.
  Dabei zeigt der übergebene boolean Wert 'is_connected' an ob man connected wurde, oder disconnected wurde.
  Zukünftige Implementierungen könnten dies beispielweise folgendermaßen erweitern:

     void on_connection_change(bool server_changed, bool is_connected) 

  'server_changed' könnte dann anzeigen ob der Server derselbe ist wie vorher.

- Ableitung von den oben beschriebenen abstrakten Klassen AbstractItemlist und AbstractFilebrowser,
  um die fill_* Funktionen von MPD::Client benutzen zu können.

=============================================


  Referenzen:
  - libmpdclient API Referenz: http://www.musicpd.org/doc/libmpdclient/files.html
  - ncmpc homepage: http://mpd.wikia.com/wiki/Client:Ncmpc


  Glossar:

  Erklärungen zum MainLoop: 
   Einfach aus folgenden Seiten _zitieren_
   * http://en.wikipedia.org/wiki/Event_loop
   * http://developer.gnome.org/glib/2.30/glib-The-Main-Event-Loop.html (Part bei Description, besonders das Schaubild)


 
