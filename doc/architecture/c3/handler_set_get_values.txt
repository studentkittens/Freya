================
Config::Handler
================

Beteiligte Klassen/Libraries:
-------------------------------    
    Config::Handler (Singleton),
    Config::Model,
    Log:Writer (Singleton),
    Utils/Singleton (Utility),
    libxml/parser (externe lib),
    glib (externe lib)
    

Init des ConfigHandlers
-------------------------
    - Config::Handler ist als Singleton implementiert, Instanzierung erfolgt automatisch bzw über Aufruf der Makros.
    - Config::Handler hat eine Model Instanz als Membervariable gespeichert.


Config Handler wird immer nur über folgende Makros angesprochen werden:
------------------------------------------------------------------------

* String Werte setzen und lesen 
    - CONFIG_SET(x,y) Config::Handler::instance().set_value(x,y)
    - CONFIG_GET(x)   Config::Handler::instance().get_value(x)
   
* Integer Werte setzen und lesen
    - CONFIG_SET_AS_INT(x,y) Config::Handler::instance().set_value_as_int(x,y)
    - CONFIG_GET_AS_INT(x)   Config::Handler::instance().get_value_as_int(x)

* aktuelle config auf die Festplatte speichern 
    - CONFIG_SAVE_NOW() Config::Handler::instance().save_config_now()

* default Werte lesen
    - CONFIG_GET_DEFAULT(x) Config::Handler::instance().get_default_value(x)
    - CONFIG_GET_DEFAULT_AS_INT(x) Config::Handler::instance().get_default_value_as_int(x)


1.) Setzen eines Integer Wertes am Beispiel vom Port:
-------------------------------------------------------

    - Aufruf von CONFIG_SET_AS_INT("settings.connection.port",6667), Url ist ein ustring, Port ein Integer
      die Url ist i.d.R. in in drei Teilstrings unterteilt die durch einen Punkt abgetrennt werden.
    
    - Über das o.g. Makro wird die Wrapper Methode set_value_as_int(Glib::ustring url,int value) aufgerufen
    - Diese Methode wandelt den Integer Wert in einen String (char*) um und ruft die eigentliche set Methode 
      set_value(url, wert) mit der alten Url und dem neuen String Wert auf.
    
    # Die set_value(url, wert) Methode holt sich über cfgmodel.getDocPtr(); einen aktuellen Dokument Pointer über die Model
      Instanz (cfgmodel ist eine ist eine private Member von Typ Model)
    
        # ist der Dokument Pointer NULL, so kann kein Wert geschrieben werden, also wird über den Log:Writer
          eine entsprechende Warnung in die Logdatei geschreiben.

        # bei einem gültigem Dokument Pointer wird xmlNodePtr cur = xmlDocGetRootElement(doc) aufgeruden,
          diese liefert einen xmlNodePtr (xml node pointer) auf das root Element zurück.

        # dieser wird mittels cur=cur->xmlChildrenNode auf den folgenden Kinderknoden gesetzt (cur wird im folgenden nen Ptr auf das
          "aktuelle Node" repräsentieren)
        # die traverse(url,cur) Wrapper Methode wird, mit der zu suchenden Url und nem Pointer auf das aktuellen Node, aufgerufen.
           
            -> die traverse Methode prüft die Url auf NULL ab, ob diese gültig ist
            -> weitere Vorbeireitungen, wie setzen der Positionsmarker auf den ersten Teilstring der Url (diesenHier.dummy.dummy),
               werden getroffen und die länge dieses Teilstrings wird in einer separaten Variable gespeichert gegen welche geprüft werden kann.
            -> die private _traverse(url,marker_prev,marker_next,len,cur) Methode wird aufgerufen
                
                * diese initialisiert einen result xmlNodePtr auf NULL und prüft ob das aktuelle Node NULL ist. Ist das aktuelle 
                  Node NULL, so wird eine ensprechende Warnung in die Logdatei über den Log:Writer geschreiben und die _traverse
                  Methode gibt den in result gespeicherten NULL zurück.
                  Ist das aktuelle Node ungleich NULL so wird solange das Node ungleich NULL ist folgendes gemacht bis das gewünschte Node
                  gefunden ist:
                    
                   * prüfe Teilstring auf Gültigkeit und Länge
                   
                   * passt der bisherige Teilstring, so werden die Positionsmarker auf den zweiten Teilstring dummy.dieserhier.dummy
                      gesetzt und der zu prüfende Längenwert angepasst. Der Node Pointer wird auf das nächste
                      Verschachtelungstiefe gesetzt (cur=cur->xmlChildrendNode), eine rekursiver Aufruf der _traverse Methode
                      folgt. Passt der Teilstring nicht, so wird der xmlNodePtr cur auf das nächste Node gesetzt cur = cur->next.
                   
                   * das bisher beschriebene wird solange gemacht bis das gesuchte Node aus der Url gefunden wurde oder bis das Ende
                      des Url Strings erreicht wurde. Wird die Url gefunden, so wird das entsprechende Node im result xmlNodePointer gespeichert
                      und dieser zurückgegeben.

            -> der Rückgabewert der _traverse() Methode wird an den Aufrufer, die traverse Methode zurückgegeben
            -> die traverse Methode prüft ob dieser NULL ist, wenn ja, wird eine entsprechende Fehlermeldung über den Logwriter rausgeschreiben
               das Node wird an den Aufrufer der traverse Methode zurückgegeben (set_value())
        
        # in der set_value() Methode wird ein entsprechender Rückgabewert (ungleich NULL) in die Configdatei mittels xmlNodeSetContent(cur, value)
          geschreiben


                    
2.) Lesen eines String Wertes am Beispiel von Host:
---------------------------------------------------
    
    - Aufruf von CONFIG_GET("settings.connection.host") analog zum setzen.
    - Hier wurde wieder wie beim Lesen ein Makro aufgerufen, dieser ruft die get_value(Glib::ustring) Wrapper Methode mit dem String
      settings.connection.host auf
    - diese ruft die eigentliche private _get_value(Glib::ustring url,bool getdefault) Methode mit einem false als zweiten übergabe Parameter auf
      der zweite Parameter dient dazu der _get_value() Methode mitzuteilen ob der entsprechende Default Wert aus der einkompilierten 
      Konfigurationsdatei gelanden werden soll oder der Custom User Wert.
    - die _get_value() Methode prüft nun ob das getdefault flag auf true oder false steht. In unserem Fall auf false, also wird über die
      doc = cfgmodel.getDocPtr() der entsprechende Dokument Pointer über das Model geladen (analog Setzen eines Integer Wertes)
    - Ein xmlNodePtr cur und ein xmlChar* key werden erstellt und auf NULL initlislisiert
    - ist der doc Pointer ungleich NULL, so wird analog zum "Setzen eines Integer Wertes" der cur Pointer auf das erste Element gesetzt und traverse
      aufgerufen.
    - Anschließend wird der zurückgegeben cur Pointer auf NULL geprüft, ist dieser unglich NULL, d.h. gültig, so wird 
      key = xmlNodeListGetString(doc, cur->xmlChildrenNode, true) aufgerufen, diese Methode liefert den gesuchten Wert als xmlChar* (String) zurück
    - anschließend wird der xmlChar* in einen ustring gecastet und freigegeben. Dieser ustring wird nun an den Aufrufer der _get_value() Methode
      zurückgegben.
    - konnte kein Node ermittelt werden (d.h. cur Pointer zeigte auf NULL nach dem traversieren), so wird eine entsprechende Warnung über den
      Logwriter in die Logdatei geschreiben und anschließend wird die _get_value(url,true) Methode rekursiv mit einem true Flag aufgerufen um
      einen Default Wert zu erhalten. Nun wird am Anfang der Routine über das Model nicht der User bezogene Dokument Pointer geladen sondern
      der Default Doc Pointer über doc = cfgmodel.getDefaultPtr(). Dieser liefert einen Dokument Pointer auf das aus der einkompilierten 
      default Config bestehende Dokument Objekt. Analog zum bisherigen Verlauf beim Lesen eines String Wertes erfolgt die Suche des Default
      Wertes. Kann am Ende kein Default Wert ermittelt werden so wird an den Aufrufer eine leerer ustring "" zurückgegeben.


3.) Aufruf des CONFIG_SAVE_NOW() Makros
-----------------------------------------
    
    - Beim Aufruf dieses Makros wird die save() Methode vom Model aufgerufen, diese speichert den atkuellen Dokument Pointer als config.xml Datei
      auf die Festplatte.

 
