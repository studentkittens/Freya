\chapter{Richtlinien}
\section{Programmierrichtlinien}
\renewcommand{\labelitemi}{•}
\begin{itemize}
\item Modulare Gestaltung.
\item Sauberkeit ist wichtiger als Performance.
\item Durchgehende Anwendung des Model-View-Controller Pattern.
\item ,,make'' sollte keine Warnungen ausgeben, die man leicht umgehen könnte. (-Wall und -Wextra wird genutzt)
\item ,,make test'' soll vollständig durchlaufen.
\item Sinnvolle Variablenbenennung.
\item Keine nichtkonstanten globalen Variablen.
\item Klassenmethoden (\emph{static}) nur in Ausnahmefällen bzw. nur mit guten Gründen.
\item Valgrind darf keine Laufzeitfehler bringen, die nicht von Gtk oder anderen Bibliotheken stammen.
\item ,,camelCase'' bei Objektnamen, C-Style (function\_name()) bei Funktionsnamen - Präzise Namen.
\item Tabstop = 4 Leerzeichen, Allman-Stil.
\end{itemize}
\subsection{Begründung}
Einhaltung dieser Programmierrichtlinien sorgen für ein einfaches, übersichtliches und einheitliches Arbeiten.
Jeder sollte sich ohne größere Umstände in den Code eines anderen einlesen können. Dies gewährleistet eine
hohe Wartbarkeit der Programm-Codes und beugt außerdem Fehlern vor. Das Programm ist leicht
erweiterbar ohne große Anpassungen vornehmen zu müssen.
\section{Toolauswahl}
\begin{itemize}
\item CMake (Buildsystem)
\item g++ (C++ Compiler)
\item Valgrind (Memorydebugger)
\item git (Hosting auf Github) \footnote{\url{https://github.com/studentkittens/Freya}}
\item Glade (GUI-Designer)
\item doxygen  (Interne Dokumentationsgenerierung)
\item Devhelp (Dokumentationsbrowser)
\end{itemize}
\subsection{Begründung}
CMake wurde ausgewählt da es eine solide und vor allem einfache Syntax bietet, und zudem leicht anpassbar ist. 
Git dient zur Versionsverwaltung. Github wurde dabei als Hostingplattform ausgewählt, da das Hosting dort für Open-Source-Projekte
frei ist. Glade bietet eine solide Trennung von der grafischen  Oberfläche zum Kontrollkern des Programms. Außerdem kann mit Glade sehr
einfach eine grafische Oberfläche erstellt werden. Da man sich in C++ im Gegensatz zu Java um sehr viele Sachen selbst kümmern muss,
wurde Valgrind als Memorydebugger ausgewählt, um das Aufspüren von Fehlern zu vereinfachen.
\section{Bibliotheken}
\begin{itemize}
    \item gtkmm3 (C++ Wrapper für Gtk+) \footnote{\url{http://www.gtkmm.org/de/index.html}}
\item libmpdclient (Lowlevel MPD-Bibliothek für C) \footnote{\url{http://www.musicpd.org/doc/libmpdclient/files.html}}
\item libxml2 (XML Parser Library für C) \footnote{\url{http://xmlsoft.org/index.html}}
\item libnotify (Anzeige von Desktopnachrichten) \footnote{\url{http://developer.gnome.org/libnotify/}}
\item Avahi-glib (Interface zum Avahidaemon) \footnote{\url{http://avahi.org/wiki/WikiStart\#WhatisAvahi}}
\end{itemize}
\subsection{Begründung}
C++ wurde aufgrund persönlicher Interessen der Autoren gewählt. Außerdem gibt es für Java nur wenige
oder sehr alte Bibliotheken für dieses Projekt. Gtkmm3 bietet ein dynamisches Layout und ist
leichtgewichtiger als Qt, außerdem ist es einfacher in der Handhabung und lässt sich auf den meisten 
Desktopumgebungen besser integrieren. Swing ist aus Sicht der Autoren nicht geeignet.
Libmpdclient ist eine eigene lowlevel C-Bibliothek, die unabhängig vom eigentlichen MPD-Server ist.
Libxml2 liefert einen standardisierten Xml Parser und ist sehr leichtgewichtig, sowie auf einer großen Zahl von Systemen vorhanden.
Libnotify liefert Benachrichtigungen über interne Events und ist auf den meisten Linux
Distributionen verbreitet. Avahi-glib ist ein Interface für den optionalen Avahidaemon. Avahi 
dient als Server-Borwser, kann allerdings nur MPD Server finden, die sich per Zeroconf am Avahidaemon registriert
haben.
\\ 
Primäre Entwicklerplattform ist ein GNU/Linux-System nach Wahl. Der Client soll dabei nach Möglichkeit portabel gehalten werden, um später 
auf andere vom MPD Server unterstützte Plattformen portiert werden zu können.
