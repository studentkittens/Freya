(Halbwegs Alphabetische Ordnung)

Der Browser Namespace implementiert die einzelnen Browser die in der Sidebar angezeigt werden.
Alle Klassen in diesem namespace gehören der Controllerebene an.
Wie die meisten anderen peripheren Klassen erben diese von AbstractClientUser um Änderungen von diesem empfangen zu können. Dies wird im Folgenden nicht mehr erwähnt.

<Bei den langen Strichen sollt jeweils ein Klassendiagramm hin>

AbstractBrowser
===============
Eine abstrakte Basisklasse durch die 
  
  Gtk::Widget * get_container(void) 

..implementiert werden muss. Diese sollte den umliegenden Container des Browser als Pointer zurückgeben,
so dass GManager::BrowserList diesen (und damit seine Kinder) im Hauptbereich anzeigen kann.
Siehe auch GManager::BrowserList für die nähere Erklärung zu den anderen nicht-abstrakten Methoden dieser Klasse.

BasePopup
=========
Alle Klassen die ein Rechtsklickmenü anzeigen wollen leiten von dieser Klasse ab.
Sie erwartet in ihrem Konstruktor eine von Gtk vorgegebene UI Definition die von der abgeleitenden Klasse vorgegeben werden muss.

Ansonsten bietet die Klasse eine get_action() Methode um die eigentliche Implementierung der Aktionen nicht in die abgeleitete Klasse machen zu müssen.
<Klassendiagramm>

Im Code könnte das so aussehen:

      /* mp_Popup ist die Instanz einer von BasePopup abgeleiteten Klasse */
      mp_Popup->get_action("add_item").connect(<funktionspointer>);

    ...

    void Queue::add_item_action(void)
    {
        ...
    }

-----------------------------------------------------------

Database
--------

Database
========
Diese Klasse kontrolliert die Anzeige des Datenbankbrowsers. Sie leitet sich daher von AbstractBrowser ab um sich bei der Browserliste registrieren zu können.
Um die fill_* Methoden des AbstractItemGenerator Interface zu benutzen leitet es zudem von AbstractItemlist ab. Daher implementiert es eine add_item() Methode 
um die gewonnen Items seinem Model (einem Gtk::ListStore) hinzuzufügen.

DatabasePopup
=============
Eine Klasse die von BasePopup ableitet und das Popup definiert das auftaucht wenn man im Databasebrowser rechtsklickt.
Sie bietet die Folgenden Aktionen an die man über die Methode get_action() abfragen kann und dadurch auf diese Aktionen reagieren kann:
* db_add (Fügt Auswahl zum Ende der Queue hinzu)
* db_add_all (Fügt alles zum Ende der Queue hinzu)
* db_replace (Dasselbe wie db_add, leert aber Queue vorher)
* db_update (Sendet Server einen Updatehinweis)
* db_rescan (Sendet Server einen Rescanhinweis)

DatabaseCache
=============
Ein Zwischenspeicher für die im Databasebrowser angezeigten Ordner und Files. 
Sie fungiert als Proxy für MPD::Client und erbt daher von der AbstractItemGenerator um sich als Client ausgeben zu können.
Sie implementiert daher die fill_filelist() Methode vor, lässt aber die anderen Methoden ohne Implementierung.
Da sie auch selbst Daten dem Cache hinzufügen muss leitet sich auch von AbstractItemlist ab und implementiert daher auch eine add_item() Methode. 

Das zugrunde liegende Model ist dabei eine std::map (also eine Art Hashmap) die als Key den Pfad der zu ladenden Seite benutzt,
und als Wert ein Vektor von AbstractComposites speichert. Wird eine Seite vom cache über die fill_filelist() Methode verlangt,
so wird nachgeschaut ob im angegeben Pfad bereits eine Seite gespeichert ist, falls nicht wird sie vom Server geholt und gespeichert. 
Anschließend wird über die Elemente iteriert und an die add_item() Methode des Aufrufers weitergegeben.
Sollte sich der Server wechseln bzw. sich die Datenbank geupdated so wird der cache geleert damit die Anzeige stets aktuell ist.

-----------------------------------------------------------

Fortuna
-------

Fortuna
=======
Wurde nicht geplant :)
Zeigt eine zufällige Weisheit beim Start die es vom Konsolenprogramm 'fortune' liest. Die Nachrichten sind maximal 500 Zeichen lang.
Außerdem soll die Nachricht aus uns nicht erfindlichen Gründen in einer Sprechblase angezeigt werden die von einem Katzenkopf ausgesprochen wird.

-----------------------------------------------------------

PlaylistManager
---------------

PlaylistManager
===============
Diese Klasse kontrolliert die Anzeige des "Playlists" Browsers. Er verwaltet eine Liste der auf dem Server gespeicherten Playlisten.
Zudem werden die Aktionen des Popupmenüs implmentiert.

PlaylistManagerPopup
====================
Eine Klasse die von BasePopup ableitet und das Popup definiert das auftaucht wenn man im PlaylistManager rechtsklickt.
Sie bietet die Folgenden Aktionen an die man über die Methode get_action() abfragen kann und dadurch auf diese Aktionen reagieren kann:
* pl_append (Fügt Inhalt der ausgewählten Playlists zum Ende der Queue hinzu)
* pl_replace (Dasselbe wie pl_append, aber leert vorher Queue)
* pl_delete (Löscht Playliste aus der Liste und vom Server)

-----------------------------------------------------------

Queue
-----

Queue
=====
Diese Klasse kontrolliert die Anzeige der Queue (der aktuellen Playlist also) und auch die Verwaltung des darunter liegenden Suchfelds. 
Bei Aktivierung des Suchfelds muss die Auswahl entsprechend einer Volltextsuche gefiltert werden. 
Durch Aktivieren der Tastenkombination soll zudem der Fokus auf das Suchfeld gelegt werden.
Zudem werden die Aktionen des Popupmenüs implementiert:
* Remove - Entfernt ausgewählte Elemente aus der Queue und benachrichtigt Server.
* Clear - leert alle Daten aus dem Model, und benachrichtigt dem Server entsprechend
* Save as Playlist - Speichert aktuellen Inhalt als Playliste; Namensabfrage durch PlaylistAddDialog

Das zugrundeliegende Model ist ein Gtk::ListStore dessen Spaltenlayout durch QueueModelColumns festgelegt wird.
Als View wird ein Gtk::TreeView verwendet.

QueueMerger
===========
Diese Klasse verwaltet die eigentlichen Daten die die Queue anzeigt.
Da sie letzendlich die Daten vom Client bekommt erbt sie von AbstractItemlist
und implementiert daher eine add_item() Methode. Da sie die Änderungen auch in die Queue einpflegen muss, erwartet die Merger Klasse eine Referenz auf
das der Queue zugrunde liegende Gtk::ListStore Model, sowie deren Spaltendefinition die als drittes Argument übergeben werden muss:
            
            QueueMerger(MPD::Client& client,
                        Glib::RefPtr<Gtk::ListStore>& queue_model,
                        QueueModelColumns& queue_columns);

Die Übergabe des Clients ist dadurch bedingt dass so gut wie alle peripheren Klassen von AbstractClientUser ableiten und benötigt daher eine Referenz auf den Client.
Zudem soll QueueMerger die folgenden public Funktionen bieten:

    void disable_merge_once(void);
    
    Lässt das "Zusammenführen" einmal ausfallen. Dies ist nützlich bei der Implementierung der remove funktionalität,
    da man weiß wo ein Element gelöscht wurde, und es so aus Performancegründen explizit aus View und Model entfernen kann.
           
    void recalculate_positions(unsigned pos = 0);

    Diese Funktion kann nützlich im Zusammenhang mit disable_merge_once() sein. Löscht man etwas explizit so 

Bei einem Clientupdate das eine Änderungen in der Queue angezeigt wird, so werden über das Clientcommand fill_queue_changes() die Änderungen vom Server reingeholt.
<Zustandsdiagramm mit weiterer Auarbeitung hier>

QueueModelColumns
=================
Definiert die Spalten für die Queue, und erbt daher von Gtk::TreeModel::ColumnRecord, sodass ein Gtk::ListStore etwas damit anfangen kann.
Die Definition ist nicht wie bei anderen Klassen als nested class realisiert, da sowohl Queue als auch QueueMerger darauf zugreifen müssen. 
Sie definiert die folgenden Spalten:
* m_col_id: Speichert die Songid eines Songs
* m_col_pos: Speichert die Position eines Songs (beginnend bei 0)
* m_col_title: Der Songtitel
* m_col_album: Der Albumtitel
* m_col_artist: Der Artisttitel

QueuePopup
==========
Eine Klasse die von BasePopup ableitet und das Popup definiert das auftaucht wenn man in der Queue rechtsklickt.
Sie bietet die Folgenden Aktionen an die man über die Methode get_action() abfragen kann und dadurch auf diese Aktionen reagieren kann:
* q_remove (Entfernt ausgewählte Elemente aus der Queue)
* q_clear (Leert Queue völlig)
* q_add_as_pl (Zeigt den PlaylistAddDialog)

PlaylistAddDialog
=================
Zeigt einem Dialog zum Speichern der aktuellen Queue als Playlist mit einem bestimmten Namen. Der Name wird durch den Dialog abgefragt.
Es wird keine Validierung durchgeführt, außer dass der Name länger als ein 0 Zeichen sein muss. Der eingegebene Name wird zurückgegeben.

-----------------------------------------------------------

Settings
--------

AbstractSettings
================
Eine abstrakte Klasse die einen Reiter im Settingsbrowser darstellt. 
Sie soll die folgenden pure virtual Methoden definieren:

    virtual void accept_new_settings(void)

     Weist Reiter an alle Werte in die Config zu speichern

    virtual void decline_new_settings(void)
     
     Weist Reitern die letzten validen Werte aus der Config zu laden

    virtual void reset_settings(void)

     Weist Reiter an die Defaultwerte aus der einkompilierten Config zu laden.

Settings
========
Repräsentiert den Settingsbrowser. Wie jeder andere Browser implementiert diese Klasse AbstractBrowser, und eine get_container() Methode.
Es sollen keine Änderungen direkt geändert werden, sobald sie in der GUI geändert werden, dies soll erst durch den Speichernbutton geschehen.
Sie kontrolliert die Buttons rund um die Reiter und implementiert dementsprechend deren Funktionen:
* Zurücksetzen - Setzt alle Einstellungen auf Fabrikstandards zurück
* Rückgängig - Setzt Änderungen auf letzten Stand zurück
* Speichern - Speichert aktuelle Änderungen

Die Klasse soll zudem eine Methode bieten um anzuzeigen dass die Settings geändert wurden (Sprich: ausgrauen des Speicherbuttons zB.):
 
    void settings_changed(void)

Um in jeden Tab die Settings zurückzusetzen (auf letzten validen Wert oder Standardwert) sein speichert die Settingsklasse eine Liste von AbstractSettings* 
um darüber iterieren zu können. 

<Zustandsdiagramm>

SettingsGeneral
===============
Die konkrete Klasse die den "General" Tab implementiert.
Folgende Einstellungen sollen geändert werden können:
* settings.libnotify.signal (checkbox)
* settings.libnotify.timeout (numberslider) (ausgegraut wenn 'signal' nicht aktiviert)
* settings.trayicon.tray (checkbox)
* settings.trayicon.totrayonclose (checkbox) (ausgegraut wenn 'tray' nicht aktiviert)

SettingsNetwork
===============
Die konkrete Klasse die den "Network" Tab implementiert.
Folgende Einstellungen sollen geändert werden können:
* settings.connection.port (numberslider)
* settings.connection.host (stringentry)
* settings.connection.autoconnect (checkbox)
* settings.connection.timeout (numberslider)
* settings.connection.reconnectinterval (numberslider)

SettingsPlayback
================
Die konkrete Klasse die den "Playback" Tab implementiert.
Folgende Einstellungen sollen geändert werden können:
* Eine Einstellung zum Crossfade (Überblendzeit) - wird vom Server gespeichert!
* settings.playback.stoponexit (checkbox)

SettingsOutputs
===============
Zeigt und verwaltet eine Liste von Outputs. Die Klasse benutzt die Funktion fill_outputs() von AbstractItemGenerator
und muss daher von AbstractItemlist erben.

Wenn Änderungen übernommen werden, so wird über die Liste iteriert und für jeden Output entsprechend enable() oder disable() aufgerufen, 
falls der Output vorher disabled, respektive enabled war.

OutputsModelColumns
===================
Die Spaltendefinition für die Outputliste.
Die Liste besteht aus dem Outputnamen (einem String), einer Anzeige ob der Aktiv ist (boolean),
und einen Pointer auf die AudioOutput Instanz um den entsprechenden Output en/disablen zu können.

-----------------------------------------------------------

Statistics
----------

Statistics
==========
Eine Browserklasse die lediglich eine Reihe von Labels verwaltet und sie bei einem Clientupdate mit den aktuellen Server Statistiken.

-----------------------------------------------------------
