Schematische Textdarstellung der Aktionen von Freya beim connecten:
===================================================================

Darstellung beim Start des Programms, gilt größtenteils auch für normales connect/disconnect.

Beteiligte Klassen:
  
  MPD::Client,
  MPD::Connection,
  MPD::Listener

Init:
 Instanzierung des Clients. 
 - Konstruktor instanziert die MPD::Connection. (Aber kein connect vorgang findet statt)
 - BaseClient (Superklasse von Client) registriert sich bei der MPD::Connection über signal_error() 
   für Fehler bei der Verbindung. Sollten Fehler auftreten wird die Funktion handle_errors() des Clients
   aufgerufen.

====================================
1) Aufruf von MPD::Client::connect() 
====================================

    * Aufruf von MPD::BaseClient::__connect()
    * Falls noch nicht connected:
      # Rufe m_Conn.connect() auf
        + Hole timeout, port und host auf der config
        + Falls sich der neue Host von 'lastHost' unterscheidet wird hostChanged auf true gesetzt
          (Dies ist bei Programmstart immer wahr)
        + Rufe mpd_connection_new() auf darunter liegender C Struktur auf
      # Falls m_Conn.connect() erfolgreich: 
        + Instanzierung eines Listeners der auf Events lauscht: mp_Listener
        + Aufruf von MPD::Client::go_idle()
          - m_Conn.check_error() - Auf Fehler prüfen
          - Falls noch nicht im Idlemode:
            ~ mp_Listener->enter(); 
        + Aufruf von mp_Listener->force_update()
          <
            Dadurch updaten sich alle GUI Elemente und sonstige Module,
            die sich zuvor beim Client registriert haben.

            force_update() löst alle möglichen events aus, wodurch in allen registrierten
            Klassen die on_client_update() Funktion aufgerufen wird.
          >
          ... wenn fertig: ...
      # Benachrichtige alle Module dass nun connected wurde:
        <
           on_connection_change(server_changed = 'lastHost', is_connected = true)
           wird für alle module aufgerufen. 
        >
   * Gebe MPD::Client::is_connected()
  
=======================================
2) Aufruf von MPD::Client::disconnect()       
=======================================

    * Aufruf von MPD::BaseClient::__disconnect()
    * Falls eine verbindung besteht:
      # Verlasse den Idlemode: mp_List->leave()
      # Lösche Listenerobjekt (wird bei jedem connect vorgang neu aufgebaut)
    * Rufe m_Conn.disconnect() auf 
      # Ruft mpd_connection_free() auf darunter liegender C Struktur auf
    * Benachrichtige alle Module über den disconnect:
        <
           on_connection_change(server_changed = false, is_connected = false)
           wird für alle module aufgerufen. 
        >
    * Returne MPD::Client::is_connected()
